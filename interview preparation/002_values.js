// Примитивные типы данных в ЖС передаются как значения, а вычисляемые значение (такие как объекты, массивы и функции) передают ссылку на объект. И из-за этого могут возникать мутации
/*
{
   let a = 42;
   let b = a; // получили значение переменной a и скопировали его в b, и дальше мы работаем уже со значением переменной b
   b++
   console.log('a', a) // 42
   console.log('b', b) // 43
}
*/

{
   let a = [1, 2, 3]
   let b = a // скопировали не сам массив, а ссылку на него. И по сути мы храним одинаковые объекты в двух переменных
   b.push(4); // при изменении переменной b - меняется и источник (a) 
   console.log('a', a) // [1, 2, 3, 4] 
   console.log('b', b) // [1, 2, 3, 4]

   // чтобы избежать вышеупомянутого повидения, мы можем возвращать клон массива (a.concat() без второго массива. Данный способ как раз и возвращает копию массива). И тогда переменная b не мутирует (не изменяет массив a)  

   let c = [1, 2, 3, 4]

   console.log(a === b) // true. В данном случае мы передаем b в качестве референса. Это одно и то же, поэтому они равны
   console.log(a === c) // false. Хоть массивы и равны, это два разных объетка. И они имеют разные значения при приведения
   // Массив - частный случай объекта
}